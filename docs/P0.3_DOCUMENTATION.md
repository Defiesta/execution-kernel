# P0.3: Constraint System Documentation

## Overview

P0.3 implements an unskippable, auditable constraint engine inside the zkVM guest that validates all agent-proposed actions against economic safety rules. If any rule is violated, execution provably fails and produces a Failure journal with an empty action commitment.

## Architecture

### Dataflow

1. Host provides `KernelInputV1` containing constraint_set_hash, opaque_agent_inputs, etc.
2. Guest runs agent code → returns proposed `AgentOutput`
3. Guest runs constraint engine over proposed output:
   - Validates constraint set invariants
   - Validates every action + global invariants
4. If valid:
   - Compute `action_commitment = SHA256(encoded AgentOutput)`
   - Produce `KernelJournalV1 { execution_status = Success, ... }`
5. If invalid:
   - Set `execution_status = Failure`
   - Set `action_commitment` to empty output commitment
   - Produce valid journal (proof still verifies, but verifier rejects state transition)

### Module Structure

```
crates/
├── constraints/        # Constraint engine implementation
│   └── src/lib.rs      # enforce_constraints(), payload decoders, validation
├── kernel-guest/       # Kernel integration
│   └── src/lib.rs      # kernel_main() calls constraints unconditionally
└── host-tests/         # Comprehensive test suite
    └── src/lib.rs      # 78+ tests including constraint validation
```

---

## Constraint Set (ConstraintSetV1)

The constraint set defines economic safety parameters. For P0.3, constraints are embedded in the guest binary and referenced by `constraint_set_hash`.

### Schema (60 bytes)

| Offset | Field | Type | Description |
|--------|-------|------|-------------|
| 0 | version | u32 | Must be 1 |
| 4 | max_position_notional | u64 | Maximum position size |
| 12 | max_leverage_bps | u32 | Maximum leverage (basis points) |
| 16 | max_drawdown_bps | u32 | Maximum drawdown (basis points, ≤10000) |
| 20 | cooldown_seconds | u32 | Minimum seconds between executions |
| 24 | max_actions_per_output | u32 | Maximum actions per output (≤64) |
| 28 | allowed_asset_id | [u8; 32] | Single allowed asset (zero = all allowed) |

### Invariant Validation (P0.3)

The constraint set is validated before use:
- `version` must be 1
- `max_actions_per_output` must be ≤ 64 (protocol maximum)
- `max_drawdown_bps` must be ≤ 10,000 (100%)

Invalid constraint sets return `InvalidConstraintSet` error.

### Default Values

```rust
ConstraintSetV1 {
    version: 1,
    max_position_notional: u64::MAX,  // No limit
    max_leverage_bps: 100_000,        // 10x max
    max_drawdown_bps: 10_000,         // 100% (disabled)
    cooldown_seconds: 0,              // No cooldown
    max_actions_per_output: 64,       // Protocol max
    allowed_asset_id: [0u8; 32],      // All assets allowed
}
```

---

## Action Types

### Supported Types (P0.3)

| Code | Name | Payload Size |
|------|------|--------------|
| 0x00000001 | Echo | Any (no schema) |
| 0x00000002 | OpenPosition | 45 bytes (exact) |
| 0x00000003 | ClosePosition | 32 bytes (exact) |
| 0x00000004 | AdjustPosition | 44 bytes (exact) |
| 0x00000005 | Swap | 72 bytes (exact) |

Unknown action types return `UnknownActionType` error.

### Payload Schemas

**P0.3 Strict Length Enforcement:** All payloads must be exactly the specified size. Trailing bytes are rejected to prevent encoding malleability.

#### OpenPosition (45 bytes)
| Offset | Field | Type | Size |
|--------|-------|------|------|
| 0 | asset_id | [u8; 32] | 32 |
| 32 | notional | u64 | 8 |
| 40 | leverage_bps | u32 | 4 |
| 44 | direction | u8 | 1 |

#### ClosePosition (32 bytes)
| Offset | Field | Type | Size |
|--------|-------|------|------|
| 0 | position_id | [u8; 32] | 32 |

#### AdjustPosition (44 bytes)
| Offset | Field | Type | Size |
|--------|-------|------|------|
| 0 | position_id | [u8; 32] | 32 |
| 32 | new_notional | u64 | 8 |
| 40 | new_leverage_bps | u32 | 4 |

#### Swap (72 bytes)
| Offset | Field | Type | Size |
|--------|-------|------|------|
| 0 | from_asset | [u8; 32] | 32 |
| 32 | to_asset | [u8; 32] | 32 |
| 64 | amount | u64 | 8 |

---

## State Snapshot (StateSnapshotV1)

Required for cooldown and drawdown constraints. Provided in `opaque_agent_inputs`.

### Schema (36 bytes)

| Offset | Field | Type | Size |
|--------|-------|------|------|
| 0 | snapshot_version | u32 | 4 |
| 4 | last_execution_ts | u64 | 8 |
| 12 | current_ts | u64 | 8 |
| 20 | current_equity | u64 | 8 |
| 28 | peak_equity | u64 | 8 |

### Optionality

Snapshot is optional unless cooldown or drawdown constraints are enabled:
- If `cooldown_seconds > 0` and snapshot missing → `InvalidStateSnapshot`
- If `max_drawdown_bps < 10000` and snapshot missing → `InvalidStateSnapshot`
- Otherwise, global checks are skipped

---

## Constraint Rules

### Evaluation Order (Deterministic)

1. Validate constraint set version and invariants
2. Validate output structure (action count, payload sizes)
3. For each action (in order):
   - Validate action type is known
   - Decode and validate payload schema
   - Check asset whitelist (if applicable)
   - Check position size (if applicable)
   - Check leverage (if applicable)
4. Validate global invariants (cooldown, drawdown)
5. First violation stops evaluation

### Asset Whitelist

```
IF allowed_asset_id != [0; 32]:
    REQUIRE: asset_id == allowed_asset_id (exact match)
```

P0.3 supports single-asset whitelist only. Zero means all assets allowed.

### Cooldown

```
IF cooldown_seconds > 0:
    required_ts = last_execution_ts + cooldown_seconds
    IF overflow: InvalidStateSnapshot
    REQUIRE: current_ts >= required_ts
```

**Overflow Protection:** `checked_add` is used to prevent malicious timestamps from bypassing cooldown via saturation.

### Drawdown

```
IF max_drawdown_bps < 10000:
    IF peak_equity == 0: InvalidStateSnapshot
    drawdown_bps = (peak_equity - current_equity) * 10000 / peak_equity
    REQUIRE: drawdown_bps <= max_drawdown_bps
```

Saturating subtraction handles equity growth (current > peak = 0 drawdown).

---

## Failure Semantics

### On Constraint Violation

1. `execution_status` = Failure (0x02)
2. `action_commitment` = SHA256([0x00, 0x00, 0x00, 0x00]) (empty output)
3. Valid `KernelJournalV1` is always produced
4. Proof still verifies, but verifiers/contracts should reject state transitions

### Empty Output Commitment

```
df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119
```

This is the SHA-256 hash of an empty `AgentOutput` (action_count = 0).

### Violation Reason Codes

| Code | Name | Description |
|------|------|-------------|
| 0x01 | InvalidOutputStructure | Too many actions or payload too large |
| 0x02 | UnknownActionType | Action type not recognized |
| 0x03 | AssetNotWhitelisted | Asset not in allowed list |
| 0x04 | PositionTooLarge | Position exceeds size limit |
| 0x05 | LeverageTooHigh | Leverage exceeds limit |
| 0x06 | DrawdownExceeded | Portfolio drawdown too high |
| 0x07 | CooldownNotElapsed | Too soon since last execution |
| 0x08 | InvalidStateSnapshot | Snapshot malformed or invalid |
| 0x09 | InvalidConstraintSet | Constraint configuration invalid |
| 0x0A | InvalidActionPayload | Payload doesn't match schema |

---

## Target Field Limitation

The `action.target` field is **not validated** by the constraint engine in P0.3. This field is passed through to executor contracts without constraint enforcement.

Executor contracts are responsible for validating the target field according to their own rules.

---

## API Reference

### Primary Function

```rust
pub fn enforce_constraints(
    input: &KernelInputV1,
    proposed: &AgentOutput,
    constraint_set: &ConstraintSetV1,
) -> Result<AgentOutput, ConstraintViolation>
```

Returns the validated output (same as proposed) if all constraints pass, or a `ConstraintViolation` with reason code and optional action index.

### Integration in kernel_main

```rust
// 1. Execute agent
let proposed_output = agent.run(&input);

// 2. Enforce constraints (MANDATORY)
let (validated_output, status) = match enforce_constraints(&input, &proposed_output, &constraints) {
    Ok(output) => (output, ExecutionStatus::Success),
    Err(_) => (AgentOutput { actions: vec![] }, ExecutionStatus::Failure),
};

// 3. Compute commitment over validated output
let action_commitment = compute_action_commitment(&validated_output.encode()?);

// 4. Produce journal (always)
```

---

## Test Coverage

78 tests covering:
- Payload trailing bytes rejection (all 4 types)
- Constraint set invariant validation
- Cooldown timestamp overflow protection
- All violation reason codes
- Golden vectors for commitments
- Round-trip encoding/decoding

See `crates/host-tests/src/lib.rs` and `tests/vectors/constraints/constraint_vectors.json`.

---

## References

- Full specification: `spec/constraints.md`
- Test vectors: `tests/vectors/constraints/`
- Implementation: `crates/constraints/src/lib.rs`
