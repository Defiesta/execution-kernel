# Agent Pack

Agent Pack is a portable bundle format for distributing verifiable agents. It provides a standardized way for third-party developers to package their agents with all the cryptographic commitments needed for integrators and marketplaces to verify authenticity without touching kernel internals.

## Introduction

When you build an agent for the Execution Kernel, the compilation process produces several cryptographic artifacts that bind your code to an on-chain identity. The Agent Pack format captures these artifacts along with metadata about your agent, creating a self-contained bundle that anyone can verify.

An Agent Pack manifest answers the question: "Is this agent binary authentic, and does it match what was registered on-chain?" Integrators can perform this verification entirely offline, without needing access to the original build environment or trusting the agent developer.

## The Cryptographic Chain

The security of Agent Pack rests on a chain of cryptographic commitments that link your source code to the on-chain verifier:

```
Agent Source Code
       │
       ▼ (build.rs computes SHA-256)
agent_code_hash ─────────────────────────┐
       │                                 │
       ▼ (RISC Zero compilation)         │
    ELF Binary                           │
       │                                 │
       ├──▶ elf_sha256 (SHA-256)         │
       │                                 │
       ▼ (RISC Zero hash)                │
   image_id ─────────────────────────────┤
       │                                 │
       ▼ (deployed on-chain)             │
 Verifier Contract ◀─────────────────────┘
```

Each step in this chain is deterministic. Given the same source code and build environment, you will always get the same `agent_code_hash`, the same ELF binary, and the same `image_id`. This reproducibility is what makes verification possible.

The `image_id` is the critical link to on-chain verification. When a proof is submitted to the verifier contract, the contract checks that the proof was generated by a program with a specific `image_id`. By including the `image_id` in the manifest, integrators can verify that a given agent binary corresponds to what's registered on-chain.

## Manifest Contents

The manifest is a JSON file containing all metadata and commitments needed for verification. Here's what each field represents:

### Identity Fields

- **format_version**: Always "1" for this version of the format
- **agent_name**: Human-readable name (e.g., "yield-agent")
- **agent_version**: Semantic version (e.g., "0.1.0")
- **agent_id**: 32-byte identifier registered in the kernel

### Protocol Compatibility

- **protocol_version**: The kernel protocol version this agent targets
- **kernel_version**: The kernel version used during compilation
- **risc0_version**: RISC Zero zkVM version (e.g., "3.0.4")
- **rust_toolchain**: Rust compiler version (e.g., "1.75.0")

### Cryptographic Commitments

- **agent_code_hash**: SHA-256 of the agent code, computed at build time by `build.rs`
- **image_id**: RISC Zero IMAGE_ID computed from the ELF binary

### Artifacts

- **artifacts.elf_path**: Path to the ELF binary relative to the manifest
- **artifacts.elf_sha256**: SHA-256 of the ELF binary for integrity verification

### Build Information

- **build.cargo_lock_sha256**: SHA-256 of Cargo.lock for dependency pinning
- **build.build_command**: Exact command to reproduce the build
- **build.reproducible**: Whether reproducible builds are enabled (using Docker)

### Documentation

- **inputs**: Human-readable description of the expected input format
- **actions_profile**: Description of what actions the agent produces

### Deployment (Optional)

- **networks**: Map of network names to deployment addresses
- **git**: Repository URL and commit hash for source traceability
- **notes**: Any additional information

## Producing an Agent Pack

### Step 1: Initialize the Manifest

Start by creating a manifest template with your agent's identity:

```bash
agent-pack init \
  --name my-yield-agent \
  --version 1.0.0 \
  --agent-id 0x0000000000000000000000000000000000000000000000000000000000000042
```

This creates `./dist/agent-pack.json` with placeholder values for computed fields.

### Step 2: Build Your Agent

Build your agent using the RISC Zero toolchain. For reproducible builds, use Docker:

```bash
RISC0_USE_DOCKER=1 cargo build --release -p risc0-methods
```

The ELF binary will be in `target/riscv-guest/riscv32im-risc0-zkvm-elf/release/`.

### Step 3: Compute Hashes

Use the `compute` command to populate the cryptographic fields:

```bash
agent-pack compute \
  --elf target/riscv-guest/riscv32im-risc0-zkvm-elf/release/zkvm-guest \
  --out dist/agent-pack.json \
  --cargo-lock Cargo.lock
```

This computes and updates:
- `artifacts.elf_sha256` from the ELF binary
- `image_id` from the ELF binary (requires `--features risc0`)
- `build.cargo_lock_sha256` from your lock file

### Step 4: Fill in Documentation

Edit the manifest to add:
- A description of your input format in `inputs`
- What actions your agent produces in `actions_profile`
- Network deployment addresses in `networks`
- Git repository information in `git`

### Step 5: Verify the Manifest

Run verification to ensure everything is correct:

```bash
agent-pack verify --manifest dist/agent-pack.json
```

## Verifying an Agent Pack

Integrators receive an Agent Pack (manifest + ELF binary) and want to verify its authenticity.

### Basic Verification

Structure-only verification checks that the manifest is well-formed:

```bash
agent-pack verify --manifest agent-pack.json --structure-only
```

This validates:
- All required fields are present
- Hex strings have correct format (0x prefix, 64 hex chars)
- Version strings are valid semver
- No placeholder values remain

### Full Verification

Full verification also checks the ELF binary:

```bash
agent-pack verify --manifest agent-pack.json --base-dir ./artifacts
```

This additionally:
- Verifies the ELF file exists
- Recomputes `elf_sha256` and compares to manifest
- Recomputes `image_id` and compares to manifest (if built with `--features risc0`)

### On-Chain Verification

After offline verification passes, compare the `image_id` from the manifest against the value registered in the on-chain verifier contract. If they match, the agent binary is authentic.

## Reproducible Builds

For maximum trust, use reproducible builds with Docker:

```bash
RISC0_USE_DOCKER=1 cargo build --release -p risc0-methods
```

This ensures that anyone with the same source code and Cargo.lock can produce an identical ELF binary, which means an identical `image_id`. The `build.reproducible` field indicates whether this was used.

When verifying an agent with `reproducible: true`, integrators can:
1. Check out the source at the specified git commit
2. Run the build command
3. Compare the resulting `elf_sha256` and `image_id` to the manifest

## CLI Reference

### `agent-pack init`

Creates a new manifest template.

```
USAGE:
    agent-pack init [OPTIONS] --name <NAME> --version <VERSION> --agent-id <AGENT_ID>

OPTIONS:
    -n, --name <NAME>          Agent name
    -v, --version <VERSION>    Agent version (semver)
    -a, --agent-id <AGENT_ID>  32-byte agent ID (0x hex)
    -o, --out <PATH>           Output path [default: ./dist/agent-pack.json]
```

### `agent-pack compute`

Computes hashes from ELF binary and updates the manifest.

```
USAGE:
    agent-pack compute [OPTIONS] --elf <PATH>

OPTIONS:
    -e, --elf <PATH>           Path to ELF binary
    -o, --out <PATH>           Manifest path [default: ./dist/agent-pack.json]
        --cargo-lock <PATH>    Path to Cargo.lock for hash computation
```

Note: IMAGE_ID computation requires building with `--features risc0`.

### `agent-pack verify`

Verifies a manifest's integrity.

```
USAGE:
    agent-pack verify [OPTIONS]

OPTIONS:
    -m, --manifest <PATH>      Manifest path [default: ./dist/agent-pack.json]
    -b, --base-dir <PATH>      Base directory for resolving artifact paths
        --structure-only       Only verify manifest structure, skip file verification
```

## JSON Schema

A JSON Schema for validating manifests is available at `docs/agent-pack.schema.json`. Use it with your favorite JSON validator:

```bash
# Using ajv-cli
npx ajv validate -s docs/agent-pack.schema.json -d dist/agent-pack.json
```

## Example Manifest

See `dist/agent-pack.example.json` for a complete example using the yield agent.
