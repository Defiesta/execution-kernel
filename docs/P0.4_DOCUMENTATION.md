# Kernel SDK Documentation (P0.4)

This document provides comprehensive usage documentation for the `kernel-sdk` crate. For the formal specification, see `spec/sdk.md`.

---

## Table of Contents

1. [Quick Start](#1-quick-start)
2. [Project Setup](#2-project-setup)
3. [Agent Lifecycle](#3-agent-lifecycle)
4. [The AgentContext](#4-the-agentcontext)
5. [Producing Actions](#5-producing-actions)
6. [Parsing Inputs](#6-parsing-inputs)
7. [Math Operations](#7-math-operations)
8. [Common Patterns](#8-common-patterns)
9. [Error Handling](#9-error-handling)
10. [Testing Agents](#10-testing-agents)
11. [Building for zkVM](#11-building-for-zkvm)
12. [Constraints Integration](#12-constraints-integration)
13. [Reference Implementations](#13-reference-implementations)
14. [Troubleshooting](#14-troubleshooting)

---

## 1. Quick Start

### Minimal Agent

```rust
#![no_std]
#![no_main]

extern crate alloc;

use kernel_sdk::prelude::*;

#[no_mangle]
#[allow(improper_ctypes_definitions)]
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    // Echo the inputs back
    let action = echo_action(*ctx.agent_id, ctx.opaque_inputs.to_vec());

    let mut actions = Vec::with_capacity(1);
    actions.push(action);
    AgentOutput { actions }
}
```

### Key Requirements

1. **Function name must be `agent_main`** - no exceptions
2. **Must use `#[no_mangle]` and `extern "C"`** - for kernel linkage
3. **Must return `AgentOutput`** - even if empty
4. **Never panic** - panics invalidate the proof

---

## 2. Project Setup

### Cargo.toml

```toml
[package]
name = "my-agent"
version = "0.1.0"
edition = "2021"

[dependencies]
kernel-sdk = { path = "../kernel-sdk", default-features = false }

[features]
default = []
guest = ["kernel-sdk/guest"]

[profile.release]
opt-level = 3
lto = true
```

### Crate Attributes

```rust
// Required for zkVM guest
#![no_std]
#![no_main]

// Required for heap allocation
extern crate alloc;
```

### Feature Flags

| Feature | Purpose |
|---------|---------|
| `default` | No features enabled (recommended) |
| `guest` | Enable zkVM-specific code paths |

---

## 3. Agent Lifecycle

### Execution Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                         KERNEL                                  │
├─────────────────────────────────────────────────────────────────┤
│  1. Decode KernelInputV1 from raw bytes                         │
│  2. Construct AgentContext with validated data                  │
│  3. Call agent_main(ctx)                          ─────────┐    │
│  4. Receive AgentOutput                           ◄────────┘    │
│  5. Enforce constraints on proposed actions                     │
│  6. Commit validated output (or failure journal)                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         YOUR AGENT                              │
├─────────────────────────────────────────────────────────────────┤
│  fn agent_main(ctx: &AgentContext) -> AgentOutput {             │
│      // 1. Read context fields                                  │
│      // 2. Parse opaque_inputs                                  │
│      // 3. Apply trading logic                                  │
│      // 4. Build actions                                        │
│      // 5. Return AgentOutput                                   │
│  }                                                              │
└─────────────────────────────────────────────────────────────────┘
```

### What Agents CAN Do

- Read all fields from `AgentContext`
- Parse `opaque_inputs` using SDK byte helpers
- Perform deterministic calculations
- Produce up to 64 actions
- Return empty output (valid no-op)

### What Agents CANNOT Do

- Access system time or randomness
- Perform I/O (filesystem, network)
- Call host functions or syscalls
- Modify kernel state
- Bypass constraint enforcement

---

## 4. The AgentContext

### Structure Overview

```rust
pub struct AgentContext<'a> {
    pub protocol_version: u32,      // Wire format (must be 1)
    pub kernel_version: u32,        // Kernel semantics (must be 1)
    pub agent_id: &'a [u8; 32],     // Your unique identifier
    pub agent_code_hash: &'a [u8; 32],
    pub constraint_set_hash: &'a [u8; 32],
    pub input_root: &'a [u8; 32],   // External state snapshot
    pub execution_nonce: u64,       // Replay protection
    pub opaque_inputs: &'a [u8],    // Your input data
}
```

### Version Checking

Always check versions for forward compatibility:

```rust
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    // Defensive: reject unsupported kernel versions
    if !ctx.is_kernel_v1() {
        return AgentOutput { actions: Vec::new() };
    }

    // Your logic here...
}
```

### Reading Agent ID

The `agent_id` is commonly used as the default target:

```rust
// Use agent_id as target (dereference to get owned [u8; 32])
let target = *ctx.agent_id;

let action = echo_action(target, payload);
```

### Reading Opaque Inputs

The `opaque_inputs` field contains your custom data:

```rust
// Check if inputs exist
if ctx.inputs_is_empty() {
    return AgentOutput { actions: Vec::new() };
}

// Get input length
let len = ctx.inputs_len();

// Read raw bytes
let raw = ctx.opaque_inputs;
```

### Snapshot Prefix Convention

When constraints are enabled, the first 36 bytes contain a `StateSnapshotV1`:

```
┌────────────────────────────────────────────────────────────────┐
│  opaque_inputs                                                 │
├──────────────────────────────────┬─────────────────────────────┤
│  StateSnapshotV1 (36 bytes)      │  Agent-Specific Data        │
├──────────────────────────────────┼─────────────────────────────┤
│  Offset 0-3:   snapshot_version  │  Your custom input data     │
│  Offset 4-11:  last_execution_ts │  (model params, signals,    │
│  Offset 12-19: current_ts        │   trade instructions, etc.) │
│  Offset 20-27: current_equity    │                             │
│  Offset 28-35: peak_equity       │                             │
└──────────────────────────────────┴─────────────────────────────┘
```

Use the helper to skip the prefix:

```rust
// Get bytes after the 36-byte snapshot prefix
let agent_data = ctx.agent_inputs();

// Check if snapshot is present
if ctx.has_snapshot_prefix() {
    // Safe to parse snapshot fields from ctx.opaque_inputs[0..36]
}
```

---

## 5. Producing Actions

### Action Structure

```rust
pub struct ActionV1 {
    pub action_type: u32,       // Action kind identifier
    pub target: [u8; 32],       // Target address/identifier
    pub payload: Vec<u8>,       // Action-specific data
}
```

### Action Types

| Constant | Value | Payload Size | Description |
|----------|-------|--------------|-------------|
| `ACTION_TYPE_ECHO` | 1 | Variable | Test/debug action |
| `ACTION_TYPE_OPEN_POSITION` | 2 | 45 bytes | Open trading position |
| `ACTION_TYPE_CLOSE_POSITION` | 3 | 32 bytes | Close position |
| `ACTION_TYPE_ADJUST_POSITION` | 4 | 44 bytes | Modify position |
| `ACTION_TYPE_SWAP` | 5 | 72 bytes | Asset swap |

### Using Action Constructors

**Echo Action** - For testing:

```rust
let action = echo_action(
    *ctx.agent_id,                    // target
    ctx.opaque_inputs.to_vec(),       // payload (any bytes)
);
```

**Open Position** - Start a new trade:

```rust
let asset_id = [0x42u8; 32];  // Asset to trade

let action = open_position_action(
    *ctx.agent_id,    // target
    asset_id,         // asset identifier
    1_000_000,        // notional (position size)
    20_000,           // leverage_bps (2x = 20000)
    0,                // direction: 0 = Long, 1 = Short
);
```

**Close Position** - Exit a trade:

```rust
let position_id = [0x99u8; 32];  // Position to close

let action = close_position_action(
    *ctx.agent_id,    // target
    position_id,      // position identifier
);
```

**Adjust Position** - Modify an existing trade:

```rust
let position_id = [0x99u8; 32];

let action = adjust_position_action(
    *ctx.agent_id,    // target
    position_id,      // position to modify
    2_000_000,        // new_notional (0 = unchanged)
    15_000,           // new_leverage_bps (0 = unchanged)
);
```

**Swap** - Exchange assets:

```rust
let from_asset = [0x11u8; 32];
let to_asset = [0x22u8; 32];

let action = swap_action(
    *ctx.agent_id,    // target
    from_asset,       // source asset
    to_asset,         // destination asset
    500_000,          // amount to swap
);
```

### Building AgentOutput

Always use bounded allocation:

```rust
// Single action
let mut actions = Vec::with_capacity(1);
actions.push(action);
AgentOutput { actions }

// Multiple actions
let mut actions = Vec::with_capacity(3);
actions.push(action1);
actions.push(action2);
actions.push(action3);
AgentOutput { actions }

// No actions (valid no-op)
AgentOutput { actions: Vec::new() }
```

### Action Limits

| Limit | Value |
|-------|-------|
| Max actions per output | 64 |
| Max payload per action | 16,384 bytes |

---

## 6. Parsing Inputs

### Fixed-Offset Reading

Use when you know exact positions:

```rust
let inputs = ctx.agent_inputs();

// Read at specific offsets
let asset_id = match read_bytes32(inputs, 0) {
    Some(id) => id,
    None => return AgentOutput { actions: Vec::new() },
};

let amount = match read_u64_le(inputs, 32) {
    Some(a) => a,
    None => return AgentOutput { actions: Vec::new() },
};

let direction = match read_u8(inputs, 40) {
    Some(d) => d,
    None => return AgentOutput { actions: Vec::new() },
};
```

### Cursor-Style Reading

Use for sequential parsing with automatic offset tracking:

```rust
let inputs = ctx.agent_inputs();
let mut offset = 0;

// Each read advances offset automatically
let asset_id = match read_bytes32_at(inputs, &mut offset) {
    Some(id) => id,
    None => return AgentOutput { actions: Vec::new() },
};

let amount = match read_u64_le_at(inputs, &mut offset) {
    Some(a) => a,
    None => return AgentOutput { actions: Vec::new() },
};

let is_long = match read_bool_u8_at(inputs, &mut offset) {
    Some(b) => b,
    None => return AgentOutput { actions: Vec::new() },
};
// offset is now 41 (32 + 8 + 1)
```

### Available Readers

**Fixed-offset** (offset not modified):

```rust
read_u8(bytes, offset) -> Option<u8>
read_u32_le(bytes, offset) -> Option<u32>
read_u64_le(bytes, offset) -> Option<u64>
read_bytes32(bytes, offset) -> Option<[u8; 32]>
read_slice(bytes, offset, len) -> Option<&[u8]>
read_bool_u8(bytes, offset) -> Option<bool>
```

**Cursor-style** (offset advanced on success):

```rust
read_u8_at(bytes, &mut offset) -> Option<u8>
read_u32_le_at(bytes, &mut offset) -> Option<u32>
read_u64_le_at(bytes, &mut offset) -> Option<u64>
read_bytes32_at(bytes, &mut offset) -> Option<[u8; 32]>
read_slice_at(bytes, &mut offset, len) -> Option<&[u8]>
read_bool_u8_at(bytes, &mut offset) -> Option<bool>  // No advance on invalid!
```

### Boolean Parsing

The `read_bool_u8` functions use strict interpretation:

| Byte Value | Result |
|------------|--------|
| `0x00` | `Some(false)` |
| `0x01` | `Some(true)` |
| Any other | `None` |

For `read_bool_u8_at`, the offset is **not advanced** when returning `None` (fail-without-consuming semantics).

---

## 7. Math Operations

### Checked Arithmetic

Returns `None` on overflow/underflow/divide-by-zero:

```rust
// Addition
let sum = checked_add_u64(a, b)?;

// Subtraction
let diff = checked_sub_u64(a, b)?;

// Multiplication
let product = checked_mul_u64(a, b)?;

// Division (floor/truncation)
let quotient = checked_div_u64(a, b)?;
```

### Compound Operations

For ratio calculations, use `checked_mul_div_u64`:

```rust
// Calculate (a * b) / c safely
// This is the canonical primitive for proportional calculations
let result = checked_mul_div_u64(amount, rate, denominator)?;

// Example: 70% of 1000
let seventy_percent = checked_mul_div_u64(1000, 70, 100)?;  // = 700
```

### Saturating Arithmetic

Returns boundary values instead of overflowing:

```rust
// Returns u64::MAX on overflow
let sum = saturating_add_u64(a, b);

// Returns 0 on underflow
let diff = saturating_sub_u64(a, b);

// Returns u64::MAX on overflow
let product = saturating_mul_u64(a, b);
```

### Basis Points

Basis points (bps) are used for percentages and leverage:
- 1 bps = 0.01%
- 100 bps = 1%
- 10,000 bps = 100%

```rust
const BPS_DENOMINATOR: u64 = 10_000;

// Apply percentage: value * bps / 10000
let fee = apply_bps(amount, 50)?;  // 0.5% fee

// Calculate percentage: num * 10000 / denom
let rate_bps = calculate_bps(profit, principal)?;

// Calculate drawdown
let drawdown = drawdown_bps(current_equity, peak_equity)?;
```

### Min/Max/Clamp

```rust
let smaller = min_u64(a, b);
let larger = max_u64(a, b);
let bounded = clamp_u64(value, min, max);
```

---

## 8. Common Patterns

### Pattern: Graceful Degradation

Always return valid output, never panic:

```rust
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    // Check preconditions
    if !ctx.is_kernel_v1() {
        return AgentOutput { actions: Vec::new() };
    }

    // Parse inputs with fallback
    let params = match parse_params(ctx.agent_inputs()) {
        Some(p) => p,
        None => return AgentOutput { actions: Vec::new() },
    };

    // Compute with checked arithmetic
    let size = match checked_mul_u64(params.base, params.multiplier) {
        Some(s) => s,
        None => return AgentOutput { actions: Vec::new() },
    };

    // Build output...
}
```

### Pattern: Multi-Action Agent

Produce multiple actions in a single execution:

```rust
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    let inputs = ctx.agent_inputs();
    let mut offset = 0;

    // Read action count (bounded to prevent DoS)
    let count = match read_u8_at(inputs, &mut offset) {
        Some(c) if (c as usize) <= MAX_ACTIONS_PER_OUTPUT => c as usize,
        _ => return AgentOutput { actions: Vec::new() },
    };

    let mut actions = Vec::with_capacity(count);

    for _ in 0..count {
        let asset_id = match read_bytes32_at(inputs, &mut offset) {
            Some(id) => id,
            None => break,  // Graceful early exit
        };

        let amount = match read_u64_le_at(inputs, &mut offset) {
            Some(a) => a,
            None => break,
        };

        actions.push(open_position_action(
            *ctx.agent_id,
            asset_id,
            amount,
            10_000,  // 1x leverage
            0,       // Long
        ));
    }

    AgentOutput { actions }
}
```

### Pattern: Conditional Execution

Only act when conditions are met:

```rust
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    let inputs = ctx.agent_inputs();
    let mut offset = 0;

    // Read signal
    let signal = match read_u8_at(inputs, &mut offset) {
        Some(s) => s,
        None => return AgentOutput { actions: Vec::new() },
    };

    // Only act on specific signals
    match signal {
        0x01 => {
            // Open long position
            let action = open_position_action(/* ... */);
            let mut actions = Vec::with_capacity(1);
            actions.push(action);
            AgentOutput { actions }
        }
        0x02 => {
            // Open short position
            let action = open_position_action(/* ... */);
            let mut actions = Vec::with_capacity(1);
            actions.push(action);
            AgentOutput { actions }
        }
        _ => {
            // No action (hold)
            AgentOutput { actions: Vec::new() }
        }
    }
}
```

### Pattern: Input Validation

Validate inputs before processing:

```rust
fn validate_trade_params(
    notional: u64,
    leverage_bps: u32,
    direction: u8,
) -> bool {
    // Notional must be non-zero
    if notional == 0 {
        return false;
    }

    // Leverage must be reasonable (1x to 10x)
    if leverage_bps < 10_000 || leverage_bps > 100_000 {
        return false;
    }

    // Direction must be 0 or 1
    if direction > 1 {
        return false;
    }

    true
}
```

---

## 9. Error Handling

### Never Panic

Panicking aborts execution and invalidates the proof:

```rust
// BAD: This will panic on invalid input
let value = inputs[100];  // Index out of bounds!

// GOOD: Safe bounds checking
let value = match read_u8(inputs, 100) {
    Some(v) => v,
    None => return AgentOutput { actions: Vec::new() },
};
```

### Use Option for Fallible Operations

```rust
// Parsing might fail
fn parse_trade_signal(inputs: &[u8]) -> Option<TradeSignal> {
    let mut offset = 0;

    let asset_id = read_bytes32_at(inputs, &mut offset)?;
    let amount = read_u64_le_at(inputs, &mut offset)?;
    let direction = read_u8_at(inputs, &mut offset)?;

    if direction > 1 {
        return None;
    }

    Some(TradeSignal { asset_id, amount, direction })
}
```

### Propagate Errors with `?`

```rust
fn compute_position_size(
    equity: u64,
    risk_bps: u64,
    price: u64,
) -> Option<u64> {
    let risk_amount = apply_bps(equity, risk_bps)?;
    let position_size = checked_div_u64(risk_amount, price)?;
    Some(position_size)
}
```

---

## 10. Testing Agents

### Unit Test Setup

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use kernel_sdk::prelude::*;

    fn make_test_context<'a>(
        agent_id: &'a [u8; 32],
        inputs: &'a [u8],
    ) -> AgentContext<'a> {
        let code_hash = [0u8; 32];
        let constraint_hash = [0u8; 32];
        let input_root = [0u8; 32];

        AgentContext::new(
            1,  // protocol_version
            1,  // kernel_version
            agent_id,
            &code_hash,
            &constraint_hash,
            &input_root,
            1,  // execution_nonce
            inputs,
        )
    }

    #[test]
    fn test_agent_produces_action() {
        let agent_id = [0x42u8; 32];
        let inputs = [1, 2, 3, 4, 5];

        let ctx = make_test_context(&agent_id, &inputs);
        let output = agent_main(&ctx);

        assert_eq!(output.actions.len(), 1);
        assert_eq!(output.actions[0].action_type, ACTION_TYPE_ECHO);
    }

    #[test]
    fn test_agent_handles_empty_input() {
        let agent_id = [0x42u8; 32];
        let inputs: [u8; 0] = [];

        let ctx = make_test_context(&agent_id, &inputs);
        let output = agent_main(&ctx);

        // Should return empty output, not panic
        assert!(output.actions.is_empty() || output.actions.len() == 1);
    }
}
```

### Testing Payload Encoding

```rust
#[test]
fn test_open_position_payload() {
    let asset_id = [0x11u8; 32];
    let action = open_position_action(
        [0u8; 32],  // target
        asset_id,
        1_000_000,
        20_000,
        0,
    );

    assert_eq!(action.action_type, ACTION_TYPE_OPEN_POSITION);
    assert_eq!(action.payload.len(), 45);

    // Verify payload structure
    let decoded = decode_open_position_payload(&action.payload).unwrap();
    assert_eq!(decoded.asset_id, asset_id);
    assert_eq!(decoded.notional, 1_000_000);
    assert_eq!(decoded.leverage_bps, 20_000);
    assert_eq!(decoded.direction, 0);
}
```

### Running Tests

```bash
# Run all SDK tests
cargo test -p kernel-sdk

# Run specific test
cargo test -p kernel-sdk test_agent_produces_action

# Run with output
cargo test -p kernel-sdk -- --nocapture
```

---

## 11. Building for zkVM

### Build Configuration

```toml
# Cargo.toml for zkVM guest
[package]
name = "my-agent-guest"
edition = "2021"

[dependencies]
kernel-sdk = { path = "../kernel-sdk", default-features = false, features = ["guest"] }

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
```

### Verification Commands

```bash
# Add wasm target for no_std verification
rustup target add wasm32-unknown-unknown

# Build without std
cargo build --release --no-default-features --target wasm32-unknown-unknown

# Check for std leakage
cargo tree -e features | grep '\bstd\b'
```

### Size Optimization

```toml
[profile.release]
opt-level = "z"       # Optimize for size
lto = true            # Link-time optimization
codegen-units = 1     # Single codegen unit
panic = "abort"       # No unwinding
strip = true          # Strip symbols
```

---

## 12. Constraints Integration

### Understanding Constraint Enforcement

Agents propose actions; the kernel enforces constraints:

```
Agent Output → Constraint Engine → Validated Output or Failure
```

### Constraints That May Reject Actions

| Constraint | Condition |
|------------|-----------|
| `TooManyActions` | More than 64 actions |
| `UnknownActionType` | Invalid action_type value |
| `InvalidActionPayload` | Wrong payload size |
| `AssetNotWhitelisted` | Asset not in allowed list |
| `PositionTooLarge` | Exceeds max_position_notional |
| `LeverageTooHigh` | Exceeds max_leverage_bps |
| `CooldownNotElapsed` | Too soon after last execution |
| `DrawdownExceeded` | Portfolio drawdown too large |

### Designing for Constraints

```rust
// Check constraints will be satisfied BEFORE producing action
fn should_open_position(
    notional: u64,
    leverage_bps: u32,
    max_notional: u64,
    max_leverage: u32,
) -> bool {
    notional <= max_notional && leverage_bps <= max_leverage
}
```

### State Snapshot Usage

When cooldown or drawdown constraints are enabled, read the snapshot:

```rust
fn read_snapshot(inputs: &[u8]) -> Option<StateSnapshot> {
    if inputs.len() < 36 {
        return None;
    }

    let mut offset = 0;
    let version = read_u32_le_at(inputs, &mut offset)?;
    if version != 1 {
        return None;
    }

    Some(StateSnapshot {
        last_execution_ts: read_u64_le_at(inputs, &mut offset)?,
        current_ts: read_u64_le_at(inputs, &mut offset)?,
        current_equity: read_u64_le_at(inputs, &mut offset)?,
        peak_equity: read_u64_le_at(inputs, &mut offset)?,
    })
}
```

---

## 13. Reference Implementations

### Echo Agent

The simplest possible agent - echoes inputs back:

```rust
#[no_mangle]
#[allow(improper_ctypes_definitions)]
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    if !ctx.is_kernel_v1() {
        return AgentOutput { actions: Vec::new() };
    }

    // Truncate to max payload size
    let max_payload = MAX_ACTION_PAYLOAD_BYTES;
    let payload_len = if ctx.opaque_inputs.len() > max_payload {
        max_payload
    } else {
        ctx.opaque_inputs.len()
    };

    let action = ActionV1 {
        action_type: ACTION_TYPE_ECHO,
        target: *ctx.agent_id,
        payload: ctx.opaque_inputs[..payload_len].to_vec(),
    };

    let mut actions = Vec::with_capacity(1);
    actions.push(action);
    AgentOutput { actions }
}
```

### Trading Agent

A more complex agent that opens positions based on signals:

```rust
#[no_mangle]
#[allow(improper_ctypes_definitions)]
pub extern "C" fn agent_main(ctx: &AgentContext) -> AgentOutput {
    if !ctx.is_kernel_v1() {
        return AgentOutput { actions: Vec::new() };
    }

    // Need at least: asset_id (32) + notional (8) + direction (1) = 41 bytes
    let inputs = ctx.agent_inputs();
    if inputs.len() < 41 {
        return AgentOutput { actions: Vec::new() };
    }

    // Parse inputs
    let mut offset = 0;

    let asset_id = match read_bytes32_at(inputs, &mut offset) {
        Some(id) => id,
        None => return AgentOutput { actions: Vec::new() },
    };

    let notional = match read_u64_le_at(inputs, &mut offset) {
        Some(n) if n > 0 => n,
        _ => return AgentOutput { actions: Vec::new() },
    };

    let direction = match read_u8_at(inputs, &mut offset) {
        Some(d) if d <= 1 => d,
        _ => return AgentOutput { actions: Vec::new() },
    };

    // Create action
    let action = open_position_action(
        *ctx.agent_id,
        asset_id,
        notional,
        10_000,  // 1x leverage
        direction,
    );

    let mut actions = Vec::with_capacity(1);
    actions.push(action);
    AgentOutput { actions }
}
```

### No-Op Agent

Produces no actions (useful for testing constraint engine):

```rust
#[no_mangle]
#[allow(improper_ctypes_definitions)]
pub extern "C" fn agent_main(_ctx: &AgentContext) -> AgentOutput {
    AgentOutput { actions: Vec::new() }
}
```

---

## 14. Troubleshooting

### Common Errors

**"std not found"**
```
error[E0463]: can't find crate for `std`
```
Solution: Ensure `#![no_std]` is at the top of your crate root and all dependencies use `default-features = false`.

**"unresolved import `alloc`"**
```
error[E0432]: unresolved import `alloc`
```
Solution: Add `extern crate alloc;` after `#![no_std]`.

**"symbol `agent_main` not found"**
- Ensure function is named exactly `agent_main`
- Ensure `#[no_mangle]` attribute is present
- Ensure `pub extern "C"` linkage

**"improper_ctypes_definitions" warning**
```
warning: `extern` fn uses type `AgentOutput`, which is not FFI-safe
```
Solution: Add `#[allow(improper_ctypes_definitions)]` (this is expected for zkVM).

### Debugging Tips

1. **Use echo actions for debugging**
   ```rust
   // Debug: echo the parsed values back
   let mut debug_payload = Vec::with_capacity(16);
   write_u64_le(&mut debug_payload, computed_value);
   let debug_action = echo_action(*ctx.agent_id, debug_payload);
   ```

2. **Check input lengths**
   ```rust
   // Log input state via echo
   let len_bytes = (ctx.inputs_len() as u64).to_le_bytes();
   let debug = echo_action(*ctx.agent_id, len_bytes.to_vec());
   ```

3. **Test locally before zkVM**
   ```bash
   cargo test -p my-agent
   ```

### Performance Tips

1. **Use `Vec::with_capacity`** - Pre-allocate known sizes
2. **Avoid cloning large data** - Use references where possible
3. **Early return on invalid input** - Don't process bad data
4. **Minimize allocations** - Reuse buffers when possible

---

## Appendix: Quick Reference

### Prelude Imports

```rust
use kernel_sdk::prelude::*;
// Imports: AgentContext, AgentOutput, ActionV1, Vec,
//          all action constructors, all byte helpers,
//          all math helpers, all constants
```

### Constants

| Constant | Value |
|----------|-------|
| `MAX_ACTIONS_PER_OUTPUT` | 64 |
| `MAX_ACTION_PAYLOAD_BYTES` | 16,384 |
| `BPS_DENOMINATOR` | 10,000 |
| `SDK_VERSION` | 0x00_01_00 |

### Action Type Values

| Action | Value |
|--------|-------|
| Echo | 0x00000001 |
| Open Position | 0x00000002 |
| Close Position | 0x00000003 |
| Adjust Position | 0x00000004 |
| Swap | 0x00000005 |

### Payload Sizes

| Action | Size |
|--------|------|
| Echo | Variable |
| Open Position | 45 bytes |
| Close Position | 32 bytes |
| Adjust Position | 44 bytes |
| Swap | 72 bytes |
