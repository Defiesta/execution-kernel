# Execution Kernel — Developer Documentation (P0.1)

## Introduction

The execution kernel is the core of the protocol. It is the component that defines what it means for an off-chain agent execution to be considered valid, provable, and safe to settle on-chain. Everything else in the system exists to support, invoke, or verify the kernel. If the kernel behaves correctly, the protocol works. If it does not, no amount of surrounding infrastructure can compensate for it.

As a developer, you should think of the kernel as consensus code rather than application code. Any change that could cause two honest provers to produce different output bytes for the same input is a protocol change. This document explains how the kernel works, why it is structured the way it is, and how you are expected to use it.



## What the kernel does

The kernel takes a fully specified input, executes an agent deterministically inside a zkVM, enforces protocol constraints, and produces a cryptographic journal. That journal is the only artifact that leaves the zkVM and is the only thing that on-chain contracts or off-chain verifiers need to interpret.

From a usage perspective, the kernel answers one question and one question only: given these exact input bytes, did this exact agent code execute correctly under these exact rules, and if so, what actions did it produce?



## Determinism and canonical behavior

Determinism is the most important property of the kernel. Given the same input bytes, the kernel must always follow the same execution path and must always produce the same output bytes. This must hold across different machines, different provers, and different builds, as long as the toolchain is pinned.

Canonical behavior is how determinism is enforced. For every protocol-relevant concept, such as inputs, outputs, ordering, and hashing, the kernel defines exactly one valid representation. There are no alternative encodings, no equivalent orderings, and no tolerated ambiguities. If two implementations disagree on a single byte, they are not both correct.



## Kernel input and how to construct it

The kernel input is not just a set of parameters. It is a binding statement that defines exactly what is being proven. When you construct a kernel input, you are committing to a specific protocol version, a specific kernel implementation, a specific agent and agent binary, a specific constraint policy, a specific external state snapshot, and a specific execution instance.

The input is represented by the KernelInputV1 structure. It includes version fields, identifiers, cryptographic hashes, a replay-protection nonce, and an opaque byte array that is passed verbatim to the agent. The kernel does not interpret the opaque agent input. It only enforces size limits and canonical encoding rules.

When encoding a kernel input, you must follow the canonical little-endian encoding defined by the kernel. Length prefixes are mandatory, size limits are enforced, and any extra or trailing bytes will cause decoding to fail. If decoding fails inside the kernel, execution aborts and no proof can be produced.



## Input commitment and why it matters

After decoding the input, the kernel computes an input commitment by hashing the full input byte sequence with SHA-256. This hash is taken over the exact bytes that were provided to the kernel, without re-encoding or normalization.

This commitment ensures that the proof is bound to the precise input that was executed. It prevents operators from reinterpreting inputs after the fact and allows on-chain logic to reason about what the agent actually observed. When you use the kernel, you should always treat the input commitment as the authoritative fingerprint of the execution context.


## Agent execution model

Agents are executed as pure, deterministic functions. An agent receives an execution context and a byte array of opaque inputs and produces a structured output. Agents have no access to time, randomness, I/O, or any external state beyond what is explicitly provided to them.

The kernel always calls the agent. The agent never calls back into the kernel. This asymmetry is intentional and security-critical. It ensures that agents cannot bypass constraint checks, cannot influence commitments, and cannot affect encoding or ordering rules.

From a developer perspective, writing an agent means implementing logic that proposes actions, not logic that enforces safety. Safety is always the kernel’s responsibility.


## Agent output and action structure

An agent produces an AgentOutput, which is a collection of structured actions. Each action includes an action type identifier, a target identifier, and an opaque payload. The kernel enforces strict limits on the number of actions and the size of each payload.

These limits are enforced both when encoding and when validating the output structure. Even if an agent attempts to produce an oversized or malformed output, the kernel will detect it and abort execution.


## Canonical action ordering

Agents are not trusted to produce actions in a consistent or meaningful order. To avoid ambiguity, the kernel enforces canonical ordering during encoding. Actions are sorted deterministically by action type, then by target, and finally by payload bytes.

This sorting happens inside the encoding logic itself. As a result, it is impossible to accidentally compute a commitment over a non-canonical ordering. This guarantees that all honest provers will compute identical action commitments, even if agents emit actions in arbitrary order.

As a user of the kernel, you should assume that action order is normalized and should never rely on the original order in which an agent produced actions.


## Constraint enforcement

Constraint enforcement is mandatory. Every kernel execution validates the agent output structure and then applies the constraint policy associated with the provided constraint set hash.

In P0.1, the constraint logic was intentionally a stub that always succeeds. This locked in the protocol structure. As of P0.3, real constraint enforcement is implemented, validating action types, payload schemas, asset whitelists, position limits, leverage limits, cooldown periods, and drawdown limits.

If any constraint check fails in P0.3+, the kernel produces a `Failure` journal with an empty action commitment. The proof remains valid, but verifiers should reject the state transition. See `docs/P0.3_DOCUMENTATION.md` and `spec/constraints.md` for full constraint semantics.


## Action commitment

After canonicalizing and encoding the agent output, the kernel computes an action commitment by hashing the encoded bytes with SHA-256. This commitment binds the proof to the exact set of actions produced by the agent under canonical ordering.

On-chain settlement logic should treat the action commitment as the authoritative representation of what the agent decided to do.


## Kernel journal and how to use it

The kernel journal is the only output of a successful execution. It is a fixed-size, deterministic structure that contains all information needed for verification and settlement. It includes version fields, identity bindings, the execution nonce, the input commitment, the action commitment, and a success status.

The journal is committed to the zkVM environment only if execution succeeds. If execution fails for any reason, no journal bytes are committed and no valid proof can exist.

When you build on top of the kernel, your on-chain or off-chain verifier should decode the journal, validate its versions, and use its commitments to authorize or reject actions.


## Failure semantics

The kernel distinguishes between two types of failures:

**Hard failures** (decoding errors, version mismatches, encoding errors): No journal is produced. In the zkVM guest, these cause a panic which prevents any journal from being committed.

**Constraint violations** (P0.3+): A `Failure` journal is produced with `execution_status = 0x02` and an empty action commitment. The proof is valid, but verifiers should reject the state transition. This allows constraint violations to be provable on-chain.

In P0.1, all failures resulted in no journal. As of P0.3, constraint violations are auditable through failure journals.


## zkVM integration

The kernel itself is independent of the zkVM. It operates on raw byte slices and returns raw byte vectors. The zkVM guest wrapper is intentionally thin and exists only to read input bytes, invoke the kernel, and commit the resulting journal bytes.

As a developer, you should avoid placing logic in the guest wrapper. All protocol semantics must live in the kernel core.


## Versioning and upgrades

The kernel tracks both a protocol version and a kernel version. The protocol version governs wire format compatibility, while the kernel version governs execution semantics. Any change to encoding rules, execution logic, or ordering rules requires a kernel version bump.

Old versions are never reinterpreted. A verifier must always know exactly which kernel semantics a proof corresponds to.


## How to use the kernel correctly

To use the kernel correctly, you should construct a canonical KernelInputV1, encode it using the provided encoding rules, and pass the resulting bytes to the zkVM guest. You should never attempt to partially construct journals or commitments yourself. All commitments must be computed by the kernel.

On the verification side, you should treat the kernel journal as the single source of truth. Never trust off-chain claims about what an agent did without validating the journal and its commitments.


## Final note for developers

When working on this codebase, always ask yourself whether a change could affect determinism, encoding, ordering, or commitment computation. If the answer is yes, the change is protocol-critical and must be treated as such.

The kernel is not just another library. It is the definition of the protocol itself.