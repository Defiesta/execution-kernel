//! Build script for example-agent
//!
//! Generates a compile-time constant `AGENT_CODE_HASH` that uniquely identifies
//! this agent's source code. This hash is used by the kernel to verify that
//! the `agent_code_hash` field in `KernelInputV1` matches the actually-linked
//! agent binary.
//!
//! # What is Hashed (DEV Mode)
//!
//! In the current MVP implementation, we hash the agent's source files:
//! - `src/lib.rs` - Main agent implementation
//! - `Cargo.toml` - Dependencies and build configuration
//!
//! The hash is computed as: SHA256(src/lib.rs || 0x00 || Cargo.toml)
//!
//! # Why Source Hashing (Temporary)
//!
//! Hashing compiled artifacts (.rlib) is complex because:
//! - rlib paths depend on build configuration and target
//! - Incremental compilation creates varying outputs
//! - Cross-compilation adds further complexity
//!
//! Source hashing provides determinism for development while we design
//! the production artifact hashing mechanism.
//!
//! # Production Considerations
//!
//! In production deployments with dynamic agents, this will be replaced by:
//! - Hashing the zkVM guest ELF binary
//! - Using the RISC Zero image ID
//! - Or hashing a canonical deployment artifact
//!
//! # Binding the Proof to Agent Code
//!
//! This hash creates a cryptographic binding between:
//! 1. The `agent_code_hash` declared in `KernelInputV1` (what the verifier expects)
//! 2. The actual agent code linked into the guest (what actually runs)
//!
//! If these don't match, the kernel rejects execution with `AgentCodeHashMismatch`.
//! This prevents:
//! - Proofs generated with one agent from being replayed with different agent code
//! - Malicious substitution of agent implementations
//! - Version confusion in multi-agent deployments

use sha2::{Digest, Sha256};
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let manifest_path = Path::new(&manifest_dir);

    // Files to hash (deterministic order)
    let files_to_hash = ["src/lib.rs", "Cargo.toml"];

    // Rerun if any source file changes
    for file in &files_to_hash {
        let path = manifest_path.join(file);
        println!("cargo:rerun-if-changed={}", path.display());
    }

    // Also rerun if build.rs itself changes
    println!("cargo:rerun-if-changed=build.rs");

    // Compute hash: SHA256(file1 || 0x00 || file2 || 0x00 || ...)
    let mut hasher = Sha256::new();

    for (i, file) in files_to_hash.iter().enumerate() {
        let path = manifest_path.join(file);
        let content = fs::read(&path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));

        hasher.update(&content);

        // Add separator between files (not after last file)
        if i < files_to_hash.len() - 1 {
            hasher.update(&[0x00]);
        }
    }

    let hash: [u8; 32] = hasher.finalize().into();

    // Generate Rust source file
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir).join("agent_hash.rs");

    let mut file = fs::File::create(&out_path)
        .unwrap_or_else(|e| panic!("Failed to create {}: {}", out_path.display(), e));

    writeln!(file, "// Auto-generated by build.rs - DO NOT EDIT").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// This hash uniquely identifies the agent source code.").unwrap();
    writeln!(file, "// It is computed as SHA256(src/lib.rs || 0x00 || Cargo.toml).").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// NOTE: This is a DEV hash based on source files.").unwrap();
    writeln!(file, "// Production deployments will use artifact hashing.").unwrap();
    writeln!(file).unwrap();
    writeln!(
        file,
        "/// SHA-256 hash of the agent source code."
    )
    .unwrap();
    writeln!(file, "///").unwrap();
    writeln!(file, "/// This constant binds the zkVM proof to this specific agent implementation.").unwrap();
    writeln!(file, "/// The kernel verifies that `KernelInputV1.agent_code_hash` matches this value").unwrap();
    writeln!(file, "/// before executing the agent. A mismatch results in `KernelError::AgentCodeHashMismatch`.").unwrap();
    writeln!(file, "///").unwrap();
    writeln!(file, "/// # What is Hashed").unwrap();
    writeln!(file, "///").unwrap();
    writeln!(file, "/// DEV mode: `SHA256(src/lib.rs || 0x00 || Cargo.toml)`").unwrap();
    writeln!(file, "///").unwrap();
    writeln!(file, "/// # When This Changes").unwrap();
    writeln!(file, "///").unwrap();
    writeln!(file, "/// Any modification to the hashed source files will produce a new hash.").unwrap();
    writeln!(file, "/// This includes whitespace changes, comments, and dependency updates.").unwrap();
    write!(file, "pub const AGENT_CODE_HASH: [u8; 32] = [").unwrap();
    for (i, byte) in hash.iter().enumerate() {
        if i > 0 {
            write!(file, ", ").unwrap();
        }
        write!(file, "0x{:02x}", byte).unwrap();
    }
    writeln!(file, "];").unwrap();

    // Print hash for build logs (useful for debugging)
    let hash_hex: String = hash.iter().map(|b| format!("{:02x}", b)).collect();
    println!("cargo:warning=AGENT_CODE_HASH: {}", hash_hex);
}
